<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2022"/>

<div>
<span><div><span style="font-size: 12pt; font-weight: bold;">ECMASsript（ES）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">ES通常看做JavaScript的标准化规范，但实际上JavaScript是ECMAScript的扩展语言，在ECMAScript中只提供了最基本的语法。 JavaScript中语言本身指的就是ECMAScript。2015年开始保持每年一个版本的迭代。</span></div></div><div><img src="note_files/Image.png" type="image/png" data-filename="Image.png" width="397"/></div><div><img src="note_files/Image [1].png" type="image/png" data-filename="Image.png" width="401"/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES2015</span></font>（http://www.ecma-international.org/ecma-262/6.0/）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">ES2015产生的变化主要有4大类</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">1、解决原有语法上的一些问题或者不足（let,const）</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">2、对原有语法进行增强(结构赋值，展开运算符，参数默认值，字符串模板）</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">3、全新的对象，全新的方法，全新的功能。（promise,proxy,obj.assign()）</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">4、全新的数据类型和数据结构。(symbol,set,map)</span></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">闭包</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>一个函数内部返回一个匿名函数，这个匿名函数就称为闭包</div><div>在一个函数内部可以访问到另一个函数内的局部变量  这个函数称为闭包</div><div>闭包的形式多样，但都是局部函数全局执行</div><div>闭包是指有权访问另一个函数作用域中的变量的函数</div><div>闭包作用 ：</div><div>     可以访问一个函数内部的私有变量</div><div>     通过闭包 可以延长一个局部变量的生命周期  将一个函数内部的私有变量长期驻留在内存里</div><div>垃圾回收机制 ： 回收的是全局变量   不会回收 私有变量和函数参数</div><div>注意 ： 闭包中的this 指向 window</div><div>--------------------------------------------</div><div>var elements = [{}, {}, {}]</div><div>for (var i = 0; i &lt; elements.length; i++) {</div><div>  elements[i].onclick = (function (i) {</div><div>      return function(){</div><div>          console.log(i)</div><div>      }</div><div>  })(i)</div><div>}</div><div>elements[1].onclick()</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//1</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">let块级作用域</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>作用域-代码当中的一个成员能够起作用的范围，在ES2015之前，ES 中只有两种作用域， 全局作用域 和 函数作用域</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">ES2015中又新增加了块级作用域也就是一对{ }范围。</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">----------------------------------------------</span></div><div><font face="Monaco">模拟给dom绑定事件。</font></div><div>var elements = [{}, {}, {}]</div><div>for (<font color="#AD0000"><b>var</b></font> i = 0; i &lt; elements.length; i++) {</div><div>    elements[i].onclick = function () {</div><div>        console.log(i)</div><div>    }</div><div>}</div><div>elements[1].onclick()</div><div>//3</div><div>因为打印的i始终都是全局的变量i,当循环结束后i的值变为3，所以不管打印哪个元素的click结果都是3。</div><div>---------------------------------------------- </div><div>elements[0].onclick()</div><div>var elements = [{}, {}, {}]</div><div>for (<font color="#AD0000"><b>let</b></font> i = 0; i &lt; elements.length; i++) {</div><div>    elements[i].onclick = function () {</div><div>        console.log(i)</div><div>    }</div><div>}</div><div>elements[0].onclick()</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//0</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">i只能在块级作用域内被访问。其实内部也是一种闭包的机制。</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">----------------------------------------------</span></div><div><font face="Monaco">在for循环中还有特别之处，在for循环内部有两层作用域。</font></div><div><font face="Monaco">for(let i = 0 ; i &lt;3 ;i++){</font></div><div><font face="Monaco">    let i = 'foo'</font></div><div><font face="Monaco">    console.log(i)</font></div><div><font face="Monaco">}</font></div><div><font face="Monaco">//foo,foo,foo</font></div><div>循环体内层的i是独立的作用域。外层的i是for循环本身的作用域。</div><div>----------------------------------------------</div><div>let不会变量提升。</div><div>为什么不在for的基础上进行升级？原因为升级var的话会导致以前的项目无法运行，所以声明了新的关键词let。</div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">CONST</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco" style="font-size: 9pt;">声明一个只读的恒量/常量，在let基础上多了‘只读’特性，声明过后不允许再修改。</font></div><div><font face="Monaco" style="font-size: 9pt;">声明和赋值必须在一个语句中。</font></div><div><font face="Monaco"><font face="Monaco"><font style="font-size: 9pt;">最佳方式: 不用var ， 主要const，配合let</font><span style="font-size: 12pt;">。</span></font></font></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">数组的</span><span style="font-size: 12pt; font-weight: bold;">解</span><span style="font-size: 12pt; font-weight: bold;">构</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">从数组或对象中获取指定元素的一种快捷方式。</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const arr = [100,200,300]</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const [,,cc] = arr</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(cc)</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">// 300</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">----------------------------------------------</span></div><div>const path = '/foo/bar/zac'</div><div>const [,pathfoo,pathbar,pathzac] = path.split('/')</div><div>console.log(pathfoo,pathbar,pathzac)</div><div>// foo bar zac</div><div>----------------------------------------------</div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象的解构</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 8pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">const obj = {name:'pxr',age:18}</span></font></div><div><font style="font-size: 8pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">const { name } = obj</span></font></div><div><font style="font-size: 8pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">console.log(name)</span></font></div><div><font style="font-size: 8pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">// pxr</span></font></div><div><font><font face="Monaco" style="font-size: 8pt;">如果变量名和被解构出来的属性名冲突，可以重定向。</font></font></div><div><font><font face="Monaco" style="font-size: 8pt;"><br/></font></font></div><div><font style="font-size: 8pt;">const obj = {name:'pxr',age:18}</font></div><div><font style="font-size: 8pt;">const name = ‘park’</font></div><div><font style="font-size: 8pt;">const {name:objName} = obj</font></div><div><font style="font-size: 8pt;">console.log(objName)</font></div><div><font><font face="Monaco" style="font-size: 8pt;">// pxr</font></font></div><div><font><font face="Monaco" style="font-size: 8pt;">----------------------------------------------</font></font></div><div><font><font face="Monaco" style="font-size: 8pt;">可以添加默认值</font></font></div><div><font style="font-size: 8pt;">const obj = {age:18}</font></div><div><font style="font-size: 8pt;">const name = 'park'</font></div><div><font style="font-size: 8pt;">const {name:objName = 'hah'} = obj</font></div><div><font style="font-size: 8pt;">console.log(objName)</font></div><div><font style="font-size: 8pt;">// hah</font></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">模板字符串</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>用反引号``</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">1、支持换行</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const str = `pxr</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">            park`</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(str)</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">// pxr</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    park</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">2、转义， 用反斜杠\</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const str = </span>`\`string\``</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(str)</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">// `string`</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">3、支持插值表达式的方式在字符串中嵌入对应的数值</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const name = 'pxr'</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const msg = `hello, ${name}`</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(msg)</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">${}里的内容是标准标准的js，不仅仅可以嵌入变量，还可以嵌入任何标准的js语句，输出返回值</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const msg = `${1+2}---${Math.random()}`</span></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">模板字符串标签函数</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>模板字符串的标签就是一个特殊的函数，</div><div>使用这个标签就是调用这个函数</div><div>const str = console.log`hello world`</div><div>// ['hello world']</div><div><br/></div><div>const name = 'tom'</div><div>const gender = false</div><div>function myTagFunc (strings, name, gender) {</div><div>  // console.log(strings, name, gender)</div><div>  // return '123'</div><div>  const sex = gender ? 'man' : 'woman'</div><div>  return strings[0] + name + strings[1] + sex + strings[2]</div><div>}</div><div><br/></div><div>const result = myTagFunc`hey, ${name} is a ${gender}.`</div><div>console.log(result)</div><div>// hey, tom is a woman</div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">字符串的扩展方法</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>includes()</div><div>startsWith()</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">endsWith()</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const message = 'Error: foo is not defined.'</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(message.startsWith('Error'))</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//true</span></div><div>console.log(message.endsWith('.'))</div><div>//true</div><div>console.log(message.includes('foo))</div><div>//true</div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">参数默认值</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">function foo (bar,enable = true){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    console.log('foo invoked -enable:')</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    console.log(enable)</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><font face="Monaco">直接在形参后面加=号赋默认值，如果有多个参数这种带默认值的参数一定要出现在参数列表的最后。</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">剩余参数（rest parameters）</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function foo(){</div><div>    console.log(arguments)</div><div>}</div><div>foo(1,2,3,4)</div><div>// [Arguments]{'0':1 , '1':2 , '2':3 , '3':4}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//这个是一个伪数组。</span></div><div><font face="Monaco">在ES2015中可以用...的操作符来取代arguments</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">function foo (...args){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    console.log(args)</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">foo(1,2,3,4)</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//[1,2,3,4]</span></div><div><font face="Monaco">因为接受的是所有的参数，所以必须出现在参数列表的最后，并且只能使用一次。</font></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">展开数组（spread）</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="color: rgb(51, 51, 51);"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const arr = ['foo','bar','baz']</span></font></div><div><font style="color: rgb(51, 51, 51);"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log.apply(console,arr)</span></font></div><div><font style="color: rgb(51, 51, 51);"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//foo bar baz</span></font></div><div><font style="color: rgb(51, 51, 51);"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">---------------------------------------------</span></font></div><div><font style="color: rgb(51, 51, 51);"><font face="Monaco">在ES2015中可以直接用...来操作。</font></font></div><div><font style="color: rgb(51, 51, 51);"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(...arr)</span></font></div><div><font style="color: rgb(51, 51, 51);"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//foo bar baz</span></font></div></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">箭头函数</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div style="font-family: Monaco;"><font style="color: rgb(51, 51, 51);"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const inc = n=&gt; n+1</span></font></div><div style="font-family: Monaco;"><font style="color: rgb(51, 51, 51);"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(inc(100))</span></font></div><div><font style="color: rgb(51, 51, 51);"><font face="Monaco">如果只有一个参数可以省略参数里的()，如果只有一行执行代码可以省略{}</font></font></div><div><font style="color: rgb(51, 51, 51);"><font face="Monaco">如果是多行执行代码，需要被{}包裹，并且需要使用return来返回。</font></font></div><div><font style="color: rgb(51, 51, 51);"><font face="Monaco">方便了回调函数的编写。</font></font></div><div><font style="color: rgb(51, 51, 51);"><font face="Monaco">箭头函数里的this。</font></font></div><div><font style="color: rgb(51, 51, 51);"><font face="Monaco">相比于普通函数，箭头函数不会改变this指向。</font></font></div><div><font style="color: rgb(51, 51, 51);"><font face="Monaco">---------------------------------------------------</font></font></div><div><font style="color: rgb(51, 51, 51);"><font face="Monaco">普通函数的this始终指向调用这个函数的对象。</font></font></div><div><font style="color: rgb(51, 51, 51);"><font face="Monaco">const person = {</font></font></div><div><font style="color: rgb(51, 51, 51);"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    name: 'tom',</span></font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    sayHi: () =&gt; {</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        console.log(`hi, my name is ${this.name}')</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><font face="Monaco">}</font></div><div><font face="Monaco">person.sayHi()</font></div><div><font face="Monaco">//hi, my name is tom</font></div><div><font face="Monaco">---------------------------------------------------</font></div><div>箭头函数中没有this机制，所以说他不会改变this的指向，也就是说箭头函数的外边this是什么在里面拿到的就是什么。</div><div>const person = {</div><div>    name: 'tom',</div><div>    sayHi: function(){</div><div>        console.log(`hi, my name is ${this.name}')</div><div>    }</div><div>}</div><div>person.sayHi()</div><div>//hi, my name is undefined</div><div>---------------------------------------------------</div><div><font face="Monaco">箭头函数里的this始终指向它被创建时的作用域中的this</font></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对</span><span style="font-size: 12pt; font-weight: bold;">象字面量的增强</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">传统的对象字面量要求我们必须要在{}里面使用属性名：属性值这种语法</font></div><div><font face="Monaco">即便属性值是一个变量，那也必须是属性名：变量名</font></div><div><font face="Monaco">而现在变量名与要添加到对象当中的属性名一致的话，那么就可以省略掉：和变量名。</font></div><div><font face="Monaco">如果想在一个对象中添加一个函数方法，也可以省略掉：和function</font></div><div><font face="Monaco">---------------------------------------------------</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const bar = '345'</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const obj = {</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    foo:123,</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    // bar : bar</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    bar</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    // method1: function(){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    //     console.log('pxr')</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    // }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    method1(){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        </span>console.log('pxr')</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">obj.method1()</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">---------------------------------------------------</span></div><div><font face="Monaco">可以使用表达式的返回值作为对象的属性名，以前要为对象添加一个动态的属性名，我们只能在对象声明过后，通过所引起的方式，也就是[]的方式来动态添加。 在ES2015过后，对象字面量的属性名就可以通过[]直接去使用动态的值，这样的特性叫‘计算属性名’</font></div><div>---------------------------------------------------</div><div>const bar = '345'</div><div>const obj = {</div><div>    <strike>Math.random():123 <font color="#AD0000">这里不能这么添加，这里能使用的值只能是明确的值或者是符合变量名规范的名称</font></strike></div><div><span style="font-size: 9pt; font-family: Monaco;">    [Math.random()]:123 //ES2015过后可以这么定义。</span></div><div>}</div><div>obj[Math.random()] = 123</div><div>---------------------------------------------------</div></div><div><span style="font-size: 9pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">对象扩展方法</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#333333" face="Monaco"><b>Object.assign()</b></font></div><div><font color="#333333" face="Monaco">可以将多个源对象中的属性复制到一个目标对象中，如果对象之间有相同的属性那么源对象中的属性会覆盖掉目标对象中的属性。从源对象里取往目标对象中放。支持传入任意个数的对象，第一个参数是目标对象，后边的对象是源对象，返回修改后的目标对象。</font></div><div><font color="#333333" face="Monaco">----------------------------------------------------</font></div><div><font color="#333333" face="Monaco"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const source1 = {</span></font></div><div><font color="#333333" face="Monaco"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    a: 123,</span></font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    b: 123</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const target = {</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    a: 456,</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    c: 456</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const result = Object.assign(target,source1) </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(target)</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">// {a: 123 , c: 456 , b:123}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(result === target)</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">// true</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">----------------------------------------------------</span></div><div><font face="Monaco">通常用于复制一个对象</font></div><div><font face="Monaco">function func(obj){</font></div><div><font face="Monaco">    const funObj = Object.assign({},obj)</font></div><div><font face="Monaco">    funcObj.name = 'func obj'</font></div><div><font face="Monaco">    console.log(funcObj)</font></div><div><font face="Monaco">}</font></div><div><font face="Monaco">const obj = { name : 'global obj' }</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco">func(obj)</font></div><div><font face="Monaco">console.log(obj)</font></div><div><font face="Monaco">// {name : 'func obj'}</font></div><div><font face="Monaco">// {name : 'global obj'}</font></div><div><font face="Monaco">-----------------------------------------------------</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>Object.is()</b></span></div><div><font face="Monaco">用来判断两个值是否相等。</font></div><div><font face="Monaco">以前用==或===</font></div><div><font face="Monaco">==会在比较之前自动转换数据类型</font></div><div><font face="Monaco">console.log(0==false) // true</font></div><div><font face="Monaco">===严格比较两者之间数值是否相同。</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(0===false) // false</span></div><div><font face="Monaco">但是这两个有两个特殊情况</font></div><div><font face="Monaco">console.log(+0 === -0) // true</font></div><div><font face="Monaco">console.log(NaN === NaN) // false</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">ES2015以后就可以使用Object.is()方法</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Object.is(+0,-0) // false</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Object.is(NaN,NaN) // true </span></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Proxy</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco" style="font-size: 9pt;">如果想要监视某个对象的读写，以前可以使用Object.defineProperty()方法为对象添加属性，可以捕获到对象当中属性的读写过程。</font></div><div><font face="Monaco" style="font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">ES2015以后添加了Proxy类型，专门用来为对象设置访问代理器。</span></font></div><div><font face="Monaco"><font face="Monaco" style="font-size: 9pt;">相比于Object.defineProperty(),Proxy的功能更强大，也更方便。</font></font></div><div><font face="Monaco" style="font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">-------------------------------------------------------</span></font></div><div><font face="Monaco" style="font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">//proxy基本用法</span></font></div><div><font face="Monaco" style="font-size: 9pt;">const person = {</font></div><div><font face="Monaco" style="font-size: 9pt;">  name: 'pxr',</font></div><div><font face="Monaco" style="font-size: 9pt;">  age: 30</font></div><div><font face="Monaco" style="font-size: 9pt;">}</font></div><div><font face="Monaco" style="font-size: 9pt;">const personProxy = new Proxy(person,{</font></div><div><font face="Monaco" style="font-size: 9pt;">    // 监视属性读取</font></div><div><font face="Monaco" style="font-size: 9pt;">    get(target,property) {</font></div><div><font face="Monaco" style="font-size: 9pt;">        return property in target ? target[property] : 'default'</font></div><div><font face="Monaco" style="font-size: 9pt;">    },</font></div><div><font face="Monaco" style="font-size: 9pt;">    // 监视属性设置</font></div><div><font face="Monaco" style="font-size: 9pt;">    set(target , property , value) {</font></div><div><font face="Monaco" style="font-size: 9pt;">        log(target , property , value)</font></div><div><font face="Monaco" style="font-size: 9pt;">        if(property === 'age'){</font></div><div><font face="Monaco" style="font-size: 9pt;">            if(!Number.isInteger(value)){</font></div><div><font face="Monaco" style="font-size: 9pt;">                throw new TypeError(`${value} is not a Int`)</font></div><div><font face="Monaco" style="font-size: 9pt;">            }</font></div><div><font face="Monaco" style="font-size: 9pt;">        }</font></div><div><font face="Monaco" style="font-size: 9pt;">        return target[property] = value</font></div><div><font face="Monaco" style="font-size: 9pt;">        // return target</font></div><div><font face="Monaco" style="font-size: 9pt;">    }</font></div><div><font face="Monaco" style="font-size: 9pt;">})</font></div><div><font face="Monaco" style="font-size: 9pt;">console.log(personProxy.name) // pxr</font></div><div><font face="Monaco" style="font-size: 9pt;">console.log(personProxy.yyy) //default</font></div><div><font face="Monaco" style="font-size: 9pt;">personProxy.age = 20.1 // TypeError: 20.1 is not a number</font></div><div><font face="Monaco" style="font-size: 9pt;">console.log(personProxy) //</font></div><div><font face="Monaco" style="font-size: 9pt;">---------------------------------------------------------</font></div><div><font face="Monaco" style="font-size: 9pt;">proxy对比Object.defineProperty()</font></div><div><font face="Monaco" style="font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">Object.defineProperty只能监视属性的读写，Proxy能够监视到更多对象操作。</span></font></div><div><font face="Monaco" style="font-size: 9pt;">const person = {</font></div><div><font face="Monaco" style="font-size: 9pt;">  name: 'zce',</font></div><div><font face="Monaco" style="font-size: 9pt;">  age: 20</font></div><div><font face="Monaco" style="font-size: 9pt;">}</font></div><div><font face="Monaco" style="font-size: 9pt;">//监视删除操作</font></div><div><font face="Monaco" style="font-size: 9pt;">const personProxy = new Proxy(person,{</font></div><div><font face="Monaco" style="font-size: 9pt;">    deleteProperty(target,property){</font></div><div><font face="Monaco" style="font-size: 9pt;">        console.log(target,property)</font></div><div><font face="Monaco" style="font-size: 9pt;">        delete target[property]</font></div><div><font face="Monaco" style="font-size: 9pt;">    }</font></div><div><font face="Monaco" style="font-size: 9pt;">})</font></div><div><font face="Monaco" style="font-size: 9pt;">delete personProxy.age</font></div><div><font face="Monaco" style="font-size: 9pt;">console.log(person) // { name: 'pxr' }</font></div><div><font face="Monaco" style="font-size: 9pt;">---------------------------------------------------------</font></div><div><font face="Monaco" style="font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">//对数组对象的监视</span></font></div><div><font face="Monaco" style="font-size: 9pt;">const list = []</font></div><div><font face="Monaco" style="font-size: 9pt;">const listProxy = new Proxy(list, {</font></div><div><font face="Monaco" style="font-size: 9pt;">  set (target, property, value) {</font></div><div><font face="Monaco" style="font-size: 9pt;">    console.log('set', property, value)</font></div><div><font face="Monaco" style="font-size: 9pt;">    target[property] = value</font></div><div><font face="Monaco" style="font-size: 9pt;">    return true // 表示设置成功</font></div><div><font face="Monaco" style="font-size: 9pt;">  }</font></div><div><font face="Monaco" style="font-size: 9pt;">})</font></div><div><font face="Monaco" style="font-size: 9pt;">listProxy.push(100)</font></div><div><font face="Monaco" style="font-size: 9pt;">//set 0 100</font></div><div><font face="Monaco" style="font-size: 9pt;">//set length 1</font></div><div><font face="Monaco" style="font-size: 9pt;">---------------------------------------------------------</font></div><div><font face="Monaco" style="font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">//Proxy是以非侵入的方式监管了对象的读写，一个被定义好的对象，不用对对象本身进行任何的操作就可以监视到它内部成员的读写 </span></font></div><div><font face="Monaco" style="font-size: 12pt;"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></font></div></div><div> </div><div><img src="note_files/Image [2].png" type="image/png" data-filename="Image.png" width="743"/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">class类</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">E</font><font style="font-size: 9pt;">S5中都是通过定义函数，以及函数的原型对象来去实现类型。</font></div><div><font style="font-size: 9pt;">function Person(name){</font></div><div><font style="font-size: 9pt;">    this.name = name</font></div><div><font style="font-size: 9pt;">}</font></div><div><font style="font-size: 9pt;">Person.prototype.say = function(){</font></div><div><font style="font-size: 9pt;">    console.log(`hi, my name is ${this.name}`)</font></div><div><font style="font-size: 9pt;">}</font></div><div><font style="font-size: 9pt;">--------------------------------------------------</font></div><div><font style="font-size: 9pt;">在ES2015开始，可以使用class来实现</font></div><div><font style="font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">class Person {</span></font></div><div><font style="font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">    constructor(name){</span></font></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 9pt;">        this.name = name</font></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 9pt;">    }</font></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 9pt;">    say(){</font></span></div><div><font style="font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">        </span>console.log(`hi, my name is ${this.name}`)</font></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 9pt;">    }</font></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 9pt;">}</font></span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 9pt;">const p = new Person('tom')</font></span></div><div><font style="font-size: 9pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">p.say() // </span>hi, my name is tom</font></div><div><font face="Monaco" style="font-size: 9pt;">--------------------------------------------------</font></div><div><font face="Monaco"><b>类型当中的方法</b></font></div><div><font face="Monaco">一般分为实例方法和静态方法</font></div><div><font face="Monaco">实例方法是通过这个类型构造的实例对象去调用</font></div><div><font face="Monaco">静态方式是直接通过类型本身调用。</font></div><div>静态方法的使用：在方法前加上static关键字，这样该方法不会被实例继承。</div><div><font face="Monaco">类型是挂载到类型上的，所以静态方法内部this不会指向实例对象，而是指向当前的类型。</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco"><b>类的继承</b></font></div><div>class Person {</div><div>    constructor(name){</div><div>        this.name = name</div><div>    }</div><div>    say(){</div><div>        console.log(`hi, my name is ${this.name}`)</div><div>    }</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">class Student extends Person {</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    constructor(name,number){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        super(name)</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        this.number = number</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    hello(){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        super.say()</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        console.log(`my number is ${this.number}）</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const s = new Student('pxr','25')</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">s.hello()</span></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Set数据结构</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>集合，set内部的成员不允许重复。</div><div>const s = new Set()</div><div><b>s.add</b>(1).add(2).add(3).add(2) //使用add()添加数据，返回集合本身所以可以链式调用，传入的重复数据会被忽略。</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(s) // Set {1,2,3}</span></div><div><font face="Monaco">集合的遍历,</font><span style="font-family: Monaco;">使用<b>forEach()</b></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">s.forEach(i=&gt;console.log(i)) // 1 2 3</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">for( let i of s){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    console.log(i) // 1 2 3</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>s.size</b>获取集合的长度。</span></div><div><b>s.has()</b>判断是否存在某一个值，返回布尔值。</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>s.delete()</b>删除某一个值，返回布尔值，成功返回true。</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>s.clear()</b>清除集合中的全部内容。</span></div><div><font face="Monaco">---------------------------------------------------</font></div><div><font face="Monaco">数组去重</font></div><div><font face="Monaco">const arr = [1,21,23,1,23,5]</font></div><div><font style="font-family: Monaco;">const result = Array.from(new Set(arr))</font></div><div>const result = [...new Set(arr)]</div><div><font face="Monaco">console.log(result) // [1,21,23,5]</font></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Map数据结构</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">与对象很类似，都是键值对的集合，但是对象中的键只能是字符串类型。</font></div><div><font style="font-size: 12pt;"><font face="Monaco">如果给对象添加的键不是字符串，那内部就会把这个数据toString()的结果作为键。 </font></font></div><div><font style="font-size: 12pt;">const obj = {}</font></div><div><font style="font-size: 12pt;">obj[true] = 'value'</font></div><div><font style="font-size: 12pt;">obj[123] = 'value'</font></div><div><font style="font-size: 12pt;">obj[{a:1}] = 'value'</font></div><div><font style="font-size: 12pt;">console.log(Object.keys(obj)) </font></div><div><font style="font-size: 12pt;">//['123','true','[object Object]']</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const m = new Map()</font></div><div><font style="font-size: 12pt;">const obj = {name : 'pxr'}</font></div><div><font style="font-size: 12pt;">m.set(obj,100)</font></div><div><font style="font-size: 12pt;">console.log(m) // Map {{name: 'pxr'} =&gt; 100}</font></div><div><font style="font-size: 12pt;">console.log(m.get(obj)) // 100 </font></div><div><font style="font-size: 12pt;">m.has() 判断某一个键是否存在，返回布尔值。</font></div><div><font style="font-size: 12pt;">m.delete() 删除某个键</font></div><div><font style="font-size: 12pt;">m.clear() 删除所有的键值</font></div><div><font style="font-size: 12pt;">map的遍历，使用forEach</font></div><div><font style="font-size: 12pt;">m.forEach((value,key) = &gt;{</font></div><div><font style="font-size: 12pt;">    console.log(value,key) // 100 {name : 'pxr'}</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;">与对象最大的区别在于可以使用任意数据类型作为键，而对象只能使用字符串作为键。</font></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Symbol</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 10pt; font-family: Monaco;">symbol表示一个独一无二的值，通过symbol()函数创建一个symbol类型的数据，通过symbol()函数创建的每一个symbol类型的值都是唯一的。</font></div><div><font face="Monaco" style="font-size: 10pt;">const s = Symbol()</font></div><div><font face="Monaco" style="font-size: 10pt;">console.log(typeof s) //symbol</font></div><div><font face="Monaco" style="font-size: 10pt;">console.log(Symbol() === Symbol()) // false</font></div><div><font face="Monaco" style="font-size: 10pt;">------------------------------------------------</font></div><div><font face="Monaco" style="font-size: 10pt;">可以传入一个字符串作为这个值的描述文本。</font></div><div><font face="Monaco" style="font-size: 10pt;">console.log(Symbol('foo'))</font></div><div><font face="Monaco" style="font-size: 10pt;">console.log(Symbol('pxr'))</font></div><div><font face="Monaco" style="font-size: 10pt;">console.log(Symbol('bar'))</font></div><div><font face="Monaco" style="font-size: 10pt;">//Symbol(foo)</font></div><div><font face="Monaco" style="font-size: 10pt;">//Symbol(pxr)</font></div><div><font face="Monaco" style="font-size: 10pt;">//Symbol(bar)</font></div><div><font face="Monaco" style="font-size: 10pt;">------------------------------------------------</font></div><div><font face="Monaco"><font face="Monaco" style="font-size: 10pt;">从ES2015开始可以使用symbol的值作为属性名。</font></font></div><div><font face="Monaco" style="font-size: 12pt;"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const obj = {</span></font></div><div><font face="Monaco" style="font-size: 12pt;"><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    [Symbol()] : 123</span></font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(obj) // { [Symbol()] : 123 }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">------------------------------------------------</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const name = Symbol()</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const person = {</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    [name] = 'pxr',</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    say(){</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        console.log(this[name])</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><font face="Monaco">直接拿不到，只能通过say()方法拿</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">person.say()</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">-----------------------------------------------</span></div><div><font face="Monaco">每次通过Symbol()函数创建的值都是唯一的，不管传入的描述文本是不是一样的</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(Symbol('foo') === </span>Symbol('foo')) // false</div><div>如何复用一个相同的symbol值？</div><div>1、使用全局变量来实现。</div><div>2、使用symbol类型提供的静态方法实现。</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const s1 = Symbol.for('foo')</span></div><div>const s2 = Symbol.for('foo')</div><div>console.log(s1 === s2) // true</div><div>使用第二种方式，在内部维护了一个全局的注册表，为字符串和symbol值提供了一一对应的关系。如果传入的不是字符串那内部会把它转换能字符串。</div><div>console.log(Symbol.for(true) === Symbol.for('true'))</div><div>------------------------------------------------</div><div>使用symbol值作为对象的属性名时，那这个属性无法通过for...in拿到，</div><div><font face="Monaco">也无法通过</font>/Object.keys()来获取到。</div><div><font face="Monaco">如果使用JSON.stringify()序列化时也会被忽略。</font></div><div><font face="Monaco">cosnt obj = {</font></div><div><font face="Monaco">    [Symbol()] = 123,</font></div><div><font face="Monaco">    name = 'pxr'</font></div><div><font face="Monaco">}</font></div><div><font face="Monaco">for ( var key in obj ) {</font></div><div><font face="Monaco">    console.log(key) // name</font></div><div><font face="Monaco">}</font></div><div><font face="Monaco"><br/></font></div><div><font style="font-family: Monaco;">console.log(Object.keys(obj)) // ['name']</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(JSON.stringify(obj)) // {'name' : 'pxr'}</span></div><div><font face="Monaco">如果想要拿到symbol的属性名可以通过Object.getOwnPropertySymbols()</font></div><div><font style="font-family: Monaco;">console.log(Object.getOwnpropertySymbols(obj)) // [Symbol()]</font></div><div>Object.keys()拿到的是字符串的属性名。Object.getOwnpropertySymbols()拿到的是symbol类型的属性名。</div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">for...of循环</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for...of循环是一种数据统一遍历方式</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const arr = [100,200,300]</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">for (const item of arr) {</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    console.log(item)</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        if(item &gt; 100) {</span></div><div>        break //使用break 终止循环</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">    }</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">arr.forEach()//不能跳出循环</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">可迭代接口</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ES中能够表示有结构的数据类型越来越多。ES2015提供了Iterable接口。</div><div>object没有实现可迭代接口。</div><div>实现interable接口的特点：</div><div>所有可以被for...of循环遍历的数据类型必须要实现Iterable接口，内部要挂载一个interator方法，这个方法需要返回一个带有next()的对象，我们不断调用这个next()方法就可以实现对内部所有数据的遍历。 </div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const set = new Set(['a','b','c'])</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">cosnt interator = set[Symbol.iterator]()</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(</span>interator.next()<span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">) // {value:'a', done: false}</span></div><div>console.log(interator.next()) // {value:'b', done: false}</div><div>console.log(interator.next()) // {value:'c', done: false}</div><div>console.log(interator.next()) // {value:undefined, done: true}</div><div>console.log(interator.next()) // {value:undefined, done: true}</div><div><br/></div><div>实现可迭代接口</div><div>-------------------------------------------------------------</div><div>const todos = {</div><div>  life: ['吃饭', '睡觉', '打豆豆'],</div><div>  learn: ['语文', '数学', '外语'],</div><div>  work: ['喝茶'],</div><div><br/></div><div><br/></div><div>  // 提供统一遍历访问接口</div><div>  each: function (callback) {</div><div>    const all = [].concat(this.life, this.learn, this.work)</div><div>    for (const item of all) {</div><div>      callback(item)</div><div>    }</div><div>  },</div><div><br/></div><div><br/></div><div>  // 提供迭代器（ES2015 统一遍历访问接口）</div><div>  [Symbol.iterator]: function () {</div><div>    const all = [...this.life, ...this.learn, ...this.work]</div><div>    let index = 0</div><div>    return {</div><div>      next: function () {</div><div>        return {</div><div>          value: all[index],</div><div>          done: index++ &gt;= all.length</div><div>        }</div><div>      }</div><div>    }</div><div>  }</div><div>}</div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Generator函数</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>function * foo () {</div><div>    console.log('zce')</div><div>    return 100</div><div>}</div><div>const result = foo() // Object [Generator] {}</div><div>console.log(result.next()) // zce {value : 100 ,done : true}</div><div>------------------------------------------------------------</div><div>function * foo () {</div><div>    console.log('111')</div><div>    yield 100</div><div>    console.log('222')</div><div>    yield 200</div><div>    console.log('333')</div><div>    yield 300</div><div>}</div><div>const result = foo()</div><div>console.log(result.next()) // 111 {value : 100 ,done : false}</div><div>console.log(result.next()) // 222 {value : 200 ,done : false}</div><div>console.log(result.next()) // 333 {value : 300 ,done : false}</div><div>-------------------------------------------------------------</div><div>生成器函数会返回一个生成器对象，调用这个生成器函数的next()方法会让这个函数的函数体开始执行。执行过程中如果遇到yield关键词，那函数的执行就会被暂停，而且yield 后面的值将会作为next的结果返回，如果继续调用next()方法，函数就会从暂停的位置继续执行，直到这个函数完全结束，next()返回的done的值也变为true，它的特点是惰性执行。</div><div>-------------------------------------------------------------</div><div>const todos = {</div><div>  life: ['吃饭', '睡觉', '打豆豆'],</div><div>  learn: ['语文', '数学', '外语'],</div><div>  work: ['喝茶'],</div><div>  [Symbol.iterator]: function * () {</div><div>    const all = [...this.life, ...this.learn, ...this.work]</div><div>    for (const item of all) {</div><div>      yield item</div><div>    }</div><div>  }</div><div>}</div><div><br/></div><div><br/></div><div>for (const item of todos) {</div><div>  console.log(item)</div><div>}</div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES2016</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Array.prototype.includes 检查数组当中是否包含指定元素</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const arr = ['foo', 1 ,NaN, false]</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(arr.indexOf('foo')) //0</span></div><div>console.log(arr.indexOf('bar')) //-1</div><div><font face="Monaco">用indexOf()会有一个问题，他不能用于查找数组当中的NaN</font></div><div>console.log(arr.indexOf(NaN)) //-1</div><div>-------------------------------------------------------</div><div><font face="Monaco">console.log(arr.includes('foo')) //true</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(arr.includes(NaN)) //true</span></div><div><br/></div><div>指数运算符</div><div>console.log(Math.pow(2,10)) //1024</div><div>console.log(2 ** 10) //1024</div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES2017</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>const obj = {</div><div>    foo : 'value1',</div><div>    bar : 'value2'</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>Object.values</b></span></div><div><font face="Monaco">与Object.keys()方法类似，Object.keys()方法返回的是对象当中所有的键组成的数组，</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Object.values()返回的是对象当中所有的值组成的数组</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">console.log(Object.values(obj)) // ['value1','value2']</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><b>Object.entries</b></span></div><div><font face="Monaco">以数组的形式返回对象中的键值对</font></div><div>const obj = {</div><div>  [Symbol()] : 123,</div><div>  name: 'pxr'</div><div>}</div><div>const res = Object.entries(obj)</div><div>console.log(res) // [ [ 'name', 'pxr' ] ]</div><div><b>Object.getOwnPropertyDescriptors</b></div><div>这个方法可以获取对象上属性的完整描述信息</div><div>const p1 = {</div><div>  firstName: 'Lei',</div><div>  lastName: 'Wang',</div><div>  get fullName () {</div><div>    return this.firstName + ' ' + this.lastName</div><div>  }</div><div>}</div><div>const descriptors = Object.getOwnPropertyDescriptors(p1)</div><div>const p2 = Object.defineProperties({}, descriptors)</div><div>p2.firstName = 'zce'</div><div>console.log(p2.fullName)</div><div><b>String.prototype.padStart / String.prototype.padEnd</b></div><div><b><br/></b></div><div>const books = {</div><div>  html: 5,</div><div>  css: 16,</div><div>  javascript: 128</div><div>}</div><div><br/></div><div><br/></div><div>for (const [name, count] of Object.entries(books)) {</div><div>  console.log(`${name.padEnd(16, '-')}|${count.toString().padStart(3, '0')}`)</div><div>}</div><div>//html------------|005</div><div>css-------------|016</div><div>javascript------|128</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 